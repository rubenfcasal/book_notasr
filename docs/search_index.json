[["index.html", "Notas de Programación en R Prólogo", " Notas de Programación en R Rubén Fernández Casal (rubenfcasal@gmail.com) Edición: Marzo de 2023. Impresión: 2023-03-30 Prólogo Este es un libro, en proceso de elaboración, con notas personales sobre programación en R para el análisis de datos, en el que incluyen referencias a información y recursos adicionales (se asumen unos conocimientos básicos de R). El contenido está sesgado por la experiencia personal (es mi forma de programar en R) pero puede resultar útil para otras personas. Cualquier sugerencia de mejora o comentario será bien recibido. Este libro ha sido escrito en R-Markdown empleando el paquete bookdown y está disponible en el repositorio Github: rubenfcasal/book_notasr. Se puede acceder a la versión en línea a través del siguiente enlace: https://rubenfcasal.github.io/book_notasr. donde puede descargarse en formato pdf. Para seguir los ejemplos mostrados en el libro (en la carpeta ejemplos se incluyen algunos ejemplos adicionales) se recomienda tener instalados los siguientes paquetes (realmente no se emplean todos): Rcmdr, caret, tidymodels, tidyverse, openxlsx, DT, rmarkdown, knitr, remotes, devtools. Por ejemplo mediante los siguientes comandos: pkgs &lt;- c(&quot;Rcmdr&quot;, &quot;caret&quot;, &quot;tidymodels&quot;, &quot;tidyverse&quot;, &quot;openxlsx&quot;, &quot;DT&quot;, &quot;rmarkdown&quot;, &quot;knitr&quot;, &quot;remotes&quot;, &quot;devtools&quot;) install.packages(setdiff(pkgs, installed.packages()[,&quot;Package&quot;]), dependencies = TRUE) (puede que haya que seleccionar el repositorio de descarga, e.g. Oficina de software libre (CIXUG)). El código anterior no reinstala los paquetes ya instalados, por lo que podrían aparecer problemas debidos a incompatibilidades entre versiones (aunque no suele ocurrir, salvo que nuestra instalación de R esté muy desactualizada). Si es el caso, en lugar de la última línea se puede ejecutar: install.packages(pkgs, dependencies = TRUE) # Instala todos... Para generar el libro (compilar) serán necesarios paquetes adicionales, para lo que se recomendaría consultar el libro de “Escritura de libros con bookdown” en castellano. Este obra está bajo una licencia de Creative Commons Reconocimiento-NoComercial-SinObraDerivada 4.0 Internacional (esperamos poder liberarlo bajo una licencia menos restrictiva más adelante…). "],["intro.html", "Capítulo 1 Introducción", " Capítulo 1 Introducción Como aparece en el prólogo, estos apuntes contienen recomendaciones y notas personales sobre programación en R para el análisis de datos, en el que incluyen referencias a información y recursos adicionales que considero de interés. Se tratará de mostrar una forma de llevar a cabo las distintas tareas que pueden surgir en el análisis de datos empleando R, esto no quiere decir que sea la mejor forma de hacerlo o la más cómoda (que dependerá de cada persona). En estas notas se asumen unos conocimientos básicos de R, un lenguaje de programación (interpretado) y un entorno estadístico desarrollado específicamente para el análisis estadístico. Puede ser una herramienta de gran utilidad a lo largo de todo el proceso de obtención de información a partir de datos (ver Figura 1.1). Figura 1.1: Etapas del proceso Para una introducción a la programación en R se puede consultar el libro: Fernández-Casal R., Roca-Pardiñas J., Costa J. y Oviedo-de la Fuente M. (2022). Introducción al Análisis de Datos con R (github). Adicionalmente, en este post se incluyen enlaces a recursos adicionales, incluyendo libros y cursos, que pueden ser útiles para el aprendizaje de R. El primer paso es la instalación de R, para ello se recomienda seguir los pasos en este post. Para el desarrollo de código e informes la recomendación es emplear RStudio Desktop, que se puede instalar y configurar siguiendo las indicaciones en este post. También puede resultar de interés consultar: RStudio cheatsheet Using the RStudio IDE Sin embargo, en ciertos casos puede ser recomendable ejecutar el código R directamente desde una ventana de comandos (por ejemplo para ejecutar varios programas de forma simultánea en distintos directorios de trabajo o si los requerimientos computacionales son grandes). En mi caso, cuando trabajo en Windows, acostumbro a emplear el explorador para situarme en el directorio donde quiero ejecutar código y abrir una ventana de comandos, escribiendo cmd en el cuadro superior donde se muestra la ruta. Posteriormente, como añadí en directorio de instalación de R al path (ver post), ejecuto1 R y finalmente un comando de la forma: source(&quot;mi_script.R&quot;, echo = TRUE, encoding = &quot;UTF-8&quot;) # UTF-8 importante en R &lt; 4.2 También se puede ejecutar un script de R de forma no interactiva ejecutando en el intérprete de comandos del sistema operativo: R CMD BATCH [opciones] mi_script.R [fichero_salida] (cambiando R por la ruta completa, e.g. \"C:\\Program Files\\R\\R-4.2.1\\bin\\R.exe\", si no se añadió al path. También se puede incluir en un fichero .bat, para poder ejecutarlo repetidas veces con mayor facilidad). Ver Appendix B Invoking R de Introduction to R para información sobre las distintas opciones.↩︎ "],["organizacion.html", "1.1 Organización", " 1.1 Organización Para la organización de archivos (datos, código, informes…) lo recomendable es emplear un directorio con la estructura adecuada. Dependiendo del objetivo puede interesar emplear un proyecto de RStudio (menú File &gt; New project…). En mi caso empleo esta opción para paquetes, libros en bookdown, webs con blogdown y aplicaciones shiny. En otros casos empleo una carpeta que puede tener subdirectorios (si el proyecto es más grande) para distintos tipos de archivos o para distintas tareas (con el objetivo de facilitar la búsqueda). Por ejemplo: datos, informes, resultados_2023… Mi recomendación es emplear nombres de archivos y carpetas en minúscula (o con la primera letra en mayúsculas), sin espacios (por ejemplo empleando _ para separar palabras o iniciales) y sin caracteres especiales (ASCII, sin acentos…). Los nombres deberían ser lo más descriptivos posibles (en el sentido de evitar confusión). Pueden incluirse descripciones más completas en el código, en ficheros de texto (e.g. Descripcion_archivos.txt), o incluso en hojas de cálculo. Yo además acostumbro a incluir archivos del tipo Notas.txt (con recordatorios, decisiones…) o Pendente.txt (con próximos pasos, mejoras o verificaciones pendientes…). Además, nos puede interesar establecer opciones de R específicas para el proyecto (por ejemplo opciones de configuración de memoria, de paquetes o variables de entorno, incluyendo claves privadas), de forma que se establezcan automáticamente al iniciar R o RStudio. Para más detalles ver la ayuda de ?Startup, el apéndice Invoking R o el post de RStudio Managing R with .Rprofile, .Renviron, Rprofile.site, Renviron.site, rsession.conf, and repos.conf Para desarrollar código y proyectos de forma colaborativa, la recomendación es emplear un sistema de control de versiones. Se puede configurar RStudio para emplear Git (ver el libro Happy Git and GitHub for the useR o la sección Git and GitHub), sin embargo yo prefiero emplear GitHub Desktop. 1.1.1 Código e informes Mi recomendación a la hora de escribir código es seguir un proceso iterativo. Se comienza realizando pruebas y al finalizar cada etapa se trata de reorganizar el código (adaptándolo al estilo de programación elegido, lo que incluiría añadir comentarios y secciones) de forma que sea más cómodo continuar trabajando en siguientes etapas (y si es posible que resulte más fácil de adaptar para otros casos). En el caso de informes el proceso sería similar, empleando como punto de partida un fichero de código en formato spin (ver e.g. Apéndice), en el que el texto RMarkdown se incluye como un comentario de código empleando #'. Por ejemplo: #&#39; # Sección #&#39; #&#39; ## Subsección #&#39; #&#39; Texto rmarkdown... En primer lugar me preocupo de escribir un código funcional y, además de ir añadiendo comentarios de la forma habitual, voy añadiendo secciones y texto rmarkdown en formato spin. Finalmente, cuando tengo una primera versión del código (que puedo ir previsualizando; en RStudio basta con pulsar2 Ctrl + Shift + K, el icono correspondiente en la barra superior, o seleccionar File &gt; Compile Report…), lo transformo a formato .Rmd con un comando de la forma: knitr::spin(&quot;Informe.R&quot;, knit = FALSE) donde termino de redactar (knitr::purl(\"Informe.Rmd\", documentation = 2) genera un nuevo fichero Informe.R donde resulta más cómodo modificar o desarrollar código). Se recomienda elegir un estilo que sea consistente y seguirlo por completo en todo el proyecto. Lo principal sería el operador de asignación, el espaciado y el estilo de nombres (de objetos, variables o ficheros): estilo.clasico: es el estilo del paquete base de R. Muchos programadores no lo recomiendan (principalmente porque este separador no se admite en otros lenguajes y porque puede dar lugar a confusión con métodos S3, ver Sección 2.3). estilo_serpiente (o Estilo_serpiente): es el estilo de la colección de paquetes tidyverse. EstiloCamello (o estiloCamello): es el estilo (casi obligatorio) para las clases R6 (ver Sección 2.3). El paquete shiny emplea la variante que comienza por minúsculas. Recomiendo emplear &lt;- como operador de asignación y escribir todos los nombres en minúsculas. Yo tengo tendencia a emplear el estilo.clasico, sobre todo si el código no depende de paquetes tidyverse (en ese caso suelo emplear estilo_serpiente). También influye el estilo de nombres empleado por la fuente de datos o el requerido en los resultados. El estilo también debe especificar el sangrado, el espaciado, etc. Por ejemplo: Tidyverse style guide Google’s R Style Guide Para facilitar la legibilidad es muy recomendable incluir un espacio entre los elementos del comando. En RStudio se puede seleccionar un trozo de (una línea de) código y pulsar Ctrl + Shift + A para formatearlo. También podemos emplear el paquete styler para formatear el código. Por ejemplo, en RStudio podemos emplear Addins &gt; Styler &gt; Style active file. Además se recomienda crear secciones y documentar el código adecuadamente. En RStudio se puede crear una sección pulsando Ctrl + Shift + R o añadiendo al menos 4 guiones (-, también = o #) después de un comentario. Por ejemplo: # Sección ---- ## Subsección ---- El orden de las secciones y subsecciones es importante. Al principio del código debería ir: Los parámetros o variables globales. La carga de paquetes (únicamente los mínimos requeridos). La carga de código externo. La carga de archivos de datos (o al principio de la sección donde se emplean, si son datos auxiliares). No se recomienda emplear rutas absolutas en el código, del tipo: setwd(&quot;C:/Documentos/Proyectos/Proyecto_X&quot;) load(&quot;C:/Documentos/Proyectos/Proyecto_X/datos_x.RData&quot;) source(&quot;C:/Documentos/Proyectos/R/Herramientas.R&quot;) Como punto de partida el directorio de trabajo debería ser la carpeta del proyecto. Esto ya ocurre por defecto si empleamos proyectos de RStudio o si iniciamos RStudio abriendo un archivo de código en esta carpeta. En general, la recomendación es asumir que el directorio de trabajo es aquel en el que se encuentra el archivo de código (lo que también ocurre por defecto al compilar un documento RMarkdown). Si no es el caso se puede emplear el menú Sesion &gt; Set Working Directory &gt; To Source File Location. Para establecer la ruta a archivos o directorios se recomienda emplear rutas relativas (usando ../ para acceder a la carpeta anterior; ./ sería el actual directorio de trabajo). Por ejemplo: load(&quot;datos/datos_x.RData&quot;) source(&quot;../R/Herramientas.R&quot;) fecha_txt &lt;- as.character(Sys.Date() - 1, format = &quot;%m_%d&quot;) # Por ejemplo... rmarkdown::render(&quot;informe.Rmd&quot;, params = list(fecha_txt = fecha_txt), output_file = paste0(&#39;informes/informe_&#39;, fecha_txt, &#39;.html&#39;), envir = new.env(), encoding = &quot;UTF-8&quot;) La mejor forma de organizar funciones es desarrollar un paquete, como se comenta más adelante en la Sección 2.4. 1.1.2 Datos La recomendación es emplear ficheros de datos con el formato por defecto de R (datos binarios comprimidos), con extensión .RData. Hay que tener en cuenta que lo esperable es que el archivo contenga un conjunto de datos con el mismo nombre, aunque podría no ser el caso e incluso contener varios objetos. Uno de los problemas con los ficheros .RData es que, al cargarlos con load() de la forma habitual, se añaden al entorno de trabajo los objetos que contienen con los nombres con que se almacenaron (y si ya existe alguno con ese nombre lo sobreescribe) Para almacenar un único objeto de forma que se pueda cargar posteriormente especificando el nombre, se pueden emplear las funciones saveRDS() y readRDS(). Sin embargo, lo habitual es que inicialmente los datos procedan de una fuente externa. Se pueden importar datos externos en casi cualquier formato a R (aunque puede requerir instalar paquetes adicionales). Mi recomendación es separar los análisis de la importación de los datos. Crear un fichero de código específicamente para importar los datos3, hacer el (pre)procesado y guardarlos en formato .RData. Yo habitualmente empleo el mismo nombre para el archivo de código y el archivo de datos que se genera (e.g. datos.R contiene el código necesario para generar datos.RData; no suelo renombrar el fichero fuente de datos externo, aunque se aleje mucho del estilo elegido). Asociado a un mismo conjunto de datos puede haber distintos archivos de código para realizar distintos análisis (el nombre de esos archivos debería dar una pista del análisis que realizan). En muchas ocasiones, para modificar los nombres de las variables o los niveles de un factor, suelo recurrir a la función dput() para escribirlos en modo texto (e.g. dput(tolower(names(datos))) o dput(levels(datos$factor))) y posteriormente modificarlos a mano. Yo recomiendo añadir un atributo variable.labels que contenga un vector de etiquetas de las variables y empleando como nombres de las componentes las propias variables: data(cars) # dput(names(cars)) var.lab &lt;- c(speed = &quot;Speed (mph)&quot;, dist = &quot;Stopping distance (ft)&quot;) attr(cars, &quot;variable.labels&quot;) &lt;- var.lab str(cars) ## &#39;data.frame&#39;: 50 obs. of 2 variables: ## $ speed: num 4 4 7 7 8 9 10 10 10 11 ... ## $ dist : num 2 10 4 22 16 10 18 26 34 17 ... ## - attr(*, &quot;variable.labels&quot;)= Named chr [1:2] &quot;Speed (mph)&quot; &quot;Stopping distance (ft)&quot; ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;speed&quot; &quot;dist&quot; # View(cars) # with(cars, plot(speed, dist, xlab = var.lab[&quot;speed&quot;], # ylab = var.lab[&quot;dist&quot;])) Para leer ficheros de Excel acostumbro a utilizar los paquetes openxlsx (solo para archivos con extensión .xlsx) o readxl (colección tidyverse; Sección 3). En estos casos además se puede añadir una nueva hoja de cálculo con los nombres de las variables junto con su etiqueta, que se puede cargar y emplear durante el preprocesado. Adicionalmente esta tabla puede incluir una columna con los nuevos nombres (yo recomiendo no modificar los antiguos en este fichero), otra con un filtro para seleccionar variables (o el orden después del procesado) e incluso una columna con anotaciones o observaciones. Ver top500.R en ejemplos. Para mostrar las combinaciones de teclas en RStudio podemos emplear el menú Tools &gt; Keyboard Shortcuts Help.↩︎ Con algunos tipos de datos, se puede emplear los submenús de RStudio File &gt; Import Dataset para seleccionar los ajustes, previsualizando el resultado, y generar el código para importarlos.↩︎ "],["r.html", "Capítulo 2 El lenguaje R", " Capítulo 2 El lenguaje R Cualquier análisis de R requiere programación, aunque normalmente se puede llevar a cabo sin conocimientos profundos del lenguaje (useR). Sin embargo, para desarrollar nuevas herramientas de forma efectiva (programeR) es necesario tener una idea del funcionamiento interno de R. La referencia recomendada para usuarios de R que deseen mejorar sus conocimientos de programación y comprensión del lenguaje es: Wickham, Hadley (2019). Advanced R, 2ª edición, Chapman &amp; Hall, 1ª edición. También puede ser de utilidad el manual R Language Definition para consultas adicionales4. Los manuales oficiales también están disponibles en formato bookdown en este post.↩︎ "],["paquetes.html", "2.1 Paquetes", " 2.1 Paquetes Al instalar R se instalan los denominados paquetes base y (por defecto) los paquetes recomendados por los desarrolladores de R (el R Core Team). Podemos acceder a la lista de paquetes instalados: pkgs &lt;- installed.packages() names(which(pkgs[ ,&quot;Priority&quot;] == &quot;base&quot;)) ## [1] &quot;base&quot; &quot;compiler&quot; &quot;datasets&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;grid&quot; ## [7] &quot;methods&quot; &quot;parallel&quot; &quot;splines&quot; &quot;stats&quot; &quot;stats4&quot; &quot;tcltk&quot; ## [13] &quot;tools&quot; &quot;utils&quot; names(which(pkgs[ ,&quot;Priority&quot;] == &quot;recommended&quot;)) ## [1] &quot;boot&quot; &quot;class&quot; &quot;cluster&quot; &quot;codetools&quot; &quot;foreign&quot; ## [6] &quot;KernSmooth&quot; &quot;lattice&quot; &quot;MASS&quot; &quot;Matrix&quot; &quot;mgcv&quot; ## [11] &quot;nlme&quot; &quot;nnet&quot; &quot;rpart&quot; &quot;spatial&quot; &quot;survival&quot; Para instalar paquetes adicionales se puede emplear install.packages() (actualmente, 2023-03-30, están disponibles 19331 en CRAN, incluso para interactuar con ChatGPT como gptstudio). Por ejemplo: pkgs &lt;- c(&quot;Rcmdr&quot;, &quot;caret&quot;, &quot;tidymodels&quot;, &quot;tidyverse&quot;, &quot;remotes&quot;, &quot;devtools&quot;, &quot;sf&quot;, &quot;gstat&quot;, &quot;geoR&quot;, &quot;quadprog&quot;, &quot;DEoptim&quot;, &quot;spam&quot;, &quot;openxlsx&quot;, &quot;bookdown&quot;, &quot;blogdown&quot;, &quot;pkgdown&quot;) install.packages(setdiff(pkgs, installed.packages()[,&quot;Package&quot;]), dependencies = TRUE) En Windows (y en MacOS) esta función instala por defecto paquetes compilados (type = \"binary\", que dependen del sistema operativo y de la versión R) disponibles en CRAN. Aunque podría instalar paquetes disponibles en otros repositorios. Por ejemplo: url &lt;- &quot;https://github.com/rubenfcasal/simres/releases/download/v0.1/simres_0.1.3.zip&quot; install.packages(url, repos = NULL) También se pueden instalar paquetes directamente a partir del código fuente con type = \"source\" (por defecto en Linux), pero en ciertos casos es necesario tener instaladas herramientas adicionales (por ejemplo Rtools en Windows si el paquete contiene código en C, C++ o Fortran). Esto permitiría incluso instalar paquetes retirados de CRAN (e.g. actualmente kedd), ya que siempre se mantiene el código (en un archivo comprimido de la forma paquete_x.y.z.tar.gz). Si se quieren instalar paquetes de repositorios distintos de CRAN (GitHub, GitLab, Bitbucket, …), puede ser recomendable instalar remotes. Por ejemplo: remotes::install_github(&quot;rubenfcasal/simres&quot;, INSTALL_opts = &quot;--with-keep.source&quot;) Además puede ser de utilidad mantener los comentarios originales del paquete para entender mejor el código (por ejemplo si se quiere modificar). Otras funciones que pueden ser de interés son: remove.packages(), update.packages() y available.packages(). Al iniciar el programa R se cargan por defecto en memoria los principales paquetes base, añadiéndolos a la ruta de búsqueda (a continuación del entorno de trabajo .GlobalEnv y siempre terminando con en el paquete base, el primero que se carga): search() ## [1] &quot;.GlobalEnv&quot; &quot;package:dbplyr&quot; &quot;package:forcats&quot; ## [4] &quot;package:stringr&quot; &quot;package:dplyr&quot; &quot;package:purrr&quot; ## [7] &quot;package:readr&quot; &quot;package:tidyr&quot; &quot;package:tibble&quot; ## [10] &quot;package:ggplot2&quot; &quot;package:tidyverse&quot; &quot;package:magrittr&quot; ## [13] &quot;package:stats&quot; &quot;package:graphics&quot; &quot;package:grDevices&quot; ## [16] &quot;package:utils&quot; &quot;package:datasets&quot; &quot;package:methods&quot; ## [19] &quot;Autoloads&quot; &quot;package:base&quot; Concretamente se añade a la ruta de búsqueda un entorno que contiene el conjunto de objetos exportables del paquete, definido en el denominado namespace del paquete. Esta ruta determina los objetos visibles en el entorno global y el orden en se buscan (para más detalles ver 7.2 Environment basics y 7.4 Special environments de Advanced R). Podemos cargar paquetes adicionales (previamente instalados) con library() o require(), por ejemplo: if (!require(knitr)) { install.packages(&quot;knitr&quot;) library(knitr) } spin(&quot;01-Introduccion.R&quot;, knit = FALSE) Aunque no se recomienda que el código instale automáticamente paquetes (en general que haga cambios en la configuración del equipo en el que se ejecuta). Al cargar un paquete se añade por defecto en la segunda posición de la ruta de búsqueda (justo después del entorno global, desplazando al resto). También se podrían añadir otros objetos, por ejemplo data.frames, con la función attach() pero no se recomienda (se puede utilizar with() como alternativa). Hay que tener cuidado con las versiones instaladas de los paquetes: packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.10&#39; y con sus dependencias (los paquetes tienen su propia ruta de búsqueda, determinada por el namespace del paquete). Al actualizar o instalar nuevos paquetes pueden aparecer problemas al ejecutar código antiguo (a veces al trabajar en nuevos proyectos acabamos haciendo que los antiguos dejen de funcionar). Se puede instalar versiones específicas de un paquete con remotes::install_version(): remotes::install_version(&quot;dplyr&quot;, version = &quot;1.11&quot;) # repos = &quot;https://ftp.cixug.es/CRAN&quot;) Para asegurarse que el código de un proyecto se pueda ejecutar a lo largo del tiempo se puede emplear el paquete renv (se puede configurar automáticamente al crear un proyecto de RStudio). Este paquete permite registrar las versiones exactas de los paquetes de los que depende un proyecto y volver a instalarlas (incluso en otro equipo) si es necesario. Para más detalles ver la viñeta Introduction to renv. Sin embargo de esta forma aún dependemos del sistema operativo que deberíamos configurar adecuadamente. La recomendación para que un proyecto en R (por ejemplo una aplicación shiny) se pueda ejecutar en cualquier equipo, es emplear un contenedor docker. Para más detalles ver Docker overview y The Rocker Project. Ver ejemplos/covid19/prediccion_cooperativa. "],["funciones.html", "2.2 Funciones", " 2.2 Funciones “Everything that happens in R is the result of a function call”. — John M. Chambers Como es bien conocido, en R se pueden asignar los argumentos de una función por posición o por nombre (del correspondiente parámetro en la definición de la función, denominado argumento formal en R). En general, la recomendación es asignar los argumentos por nombre: funcion(parametro1 = argumento1, parametro2 = argumento2, ...) De esta forma no importa el orden de los parámetros y, por ejemplo, evitaremos problemas si en el futuro hay cambios en la definición de la función. Los parámetros pueden tener valores por defecto y solo sería necesario especificarlos para asignarles un valor distinto. Podemos llamar a una función de un paquete sin necesidad de cargarlo (añadirlo a la ruta de búsqueda) empleando paquete::funcion. Esto es especialmente recomendable al desarrollar nuevas funciones (es un requisito para subir paquetes a CRAN), ya que de esta forma se evitan conflictos entre funciones con el mismo nombre en paquetes distintos. Por ejemplo: if (!requireNamespace(knitr)) stop(&quot;&#39;knitr&#39; package required&quot;) knitr::spin(&quot;01-Introduccion.R&quot;, knit = FALSE) Hay que tener en cuenta que R emplea Lazy evaluation, los argumentos no se evalúan hasta que se necesitan (lo cual puede producir mensajes de error inesperados, pero también permite añadir funcionalidades adicionales empleando la denominada evaluación no estándar o metaprogramación). R es un lenguaje interpretado y podemos evaluar expresiones empleando código. Por ejemplo, podemos reproducir el proceso de introducir un comando en la consola con las funciones eval() y parse() (aunque esta forma de proceder no es la más eficiente): eval(parse(text = &quot;1:10&quot;)) ## [1] 1 2 3 4 5 6 7 8 9 10 distr &lt;- &quot;norm&quot; # &quot;unif&quot;, &quot;exp&quot;, &quot;t&quot; ddistr &lt;- eval(parse(text = paste0(&quot;d&quot;, distr))) # str(ddistr) # curve(ddistr(x, 0, 0.5), -3, 3) Para llamar a una función especificando los parámetros de forma dinámica (empleando una lista) podemos emplear do.call(). Por ejemplo: # Listar ficheros csv files.csv &lt;- dir(path = &quot;datos&quot;, pattern = &quot;*.csv&quot;, full.names = TRUE) # Leer datos a una lista # (suponemos variante local con ; para separar valores) data.list &lt;- lapply(files.csv, read.csv2) # Combinar datos &lt;- do.call(&#39;rbind&#39;, data.list) R dispone además de otras herramientas que permiten la programación dinámica. Por ejemplo reformulate() permite construir formulas para ajuste de modelos o análisis descriptivos. Hay que tener en cuenta que las funciones tienen su propio entorno y su propia ruta de búsqueda, determinada por el entorno donde se crearon (el namespace en el caso de las funciones de un paquete). Esto es lo que se conoce como Lexical scoping. x &lt;- 1 addx &lt;- function(y) { x + y } addx(10) ## [1] 11 addx10 &lt;- function() { x &lt;- 10 # x &lt;&lt;- 10 # assign(&quot;x&quot;, 10, envir = .GlobalEnv) addx(x) } addx10() ## [1] 11 x ## [1] 1 "],["oop.html", "2.3 Programación orientada a objetos (funciones genéricas)", " 2.3 Programación orientada a objetos (funciones genéricas) “Everything that exists in R is an object”. — John M. Chambers R implementa programación orientada a objetos (OOP). Por ejemplo, es bien conocido que algunas funciones (entre ellas print(), plot() o summary()) se comportan de manera diferente dependiendo de la clase (el tipo de objeto) de sus argumentos, son las denominadas funciones genéricas. Realmente R dispone de varios sistemas de OOP, entre ellos podríamos destacar (ver capítulos en Object-oriented programming de Advanced R): S3: Es un sistema muy simple, las clases no tienen una definición formal (no se verifica su consistencia). Es el empleado en el paquete base de R y en la mayoría de paquetes que usan OOP. Descrito inicialmente en: Becker R.A., Chambers J.M. y Wilks A.R. (1988), The New S Language: A Programming Environment for Data Analysis and Graphics (A.K.A. the Blue Book). Chapman &amp; Hall. Chambers J.M. y Hastie T.J. eds. (1992), Statistical Models in S (A.K.A. the White Book). Chapman &amp; Hall. S4 (no lo recomiendo): Es similar a S3 pero mucho más formal. Está implementado en el paquete methods (uno de los paquetes base) de R. Se emplea por ejemplo en los paquetes sp y distr. Descrito inicialmente en: Chambers J.M. (1998), Programming with Data (A.K.A. the Green Book). Springer. R6: Es un sistema OOP encapsulado similar al de otros lenguajes de programación. Está implementado en el paquete R6 (no se instala por defecto). Yo en principio recomendaría usar el sistema S3, aunque es bastante rudimentario y puede resultar inicialmente confuso a programadores con experiencia en otros lenguajes. En cualquier caso es muy recomendable conocer su funcionamiento. Este sistema esta basado en funciones genéricas. La clase es un atributo de los objetos (encapsulación), una cadena de texto o un vector de cadenas (herencia), al que se puede acceder con la función class(). A partir de la clase del argumento, la función genérica determina el método (función especializada) al que debe llamar (polimorfismo). En S3 el despacho de métodos (method dispatch) es muy simple, si la función genérica es generica() y la clase del primer argumento es \"clase\", se llama a la función (método) generica.clase() si existe. Si la clase del objeto es heredada (un vector de cadenas), se van buscando los métodos por orden de parentesco y si no se encuentra ninguno, se llama al método por defecto generica.default() (se llama a la primera función de paste0(\"generica.\", c(class(x), \"default\")) que se encuentre en la ruta de búsqueda; podríamos reemplazarla…). La función genérica suele ser muy sencilla, básicamente incluye una llamada a UseMethod(\"generica\"). Por ejemplo: plot ## function (x, y, ...) ## UseMethod(&quot;plot&quot;) ## &lt;bytecode: 0x0000015c88131898&gt; ## &lt;environment: namespace:base&gt; Podemos obtener los métodos asociados a una función genérica con methods(genérica). Por ejemplo: methods(plot) ## [1] plot,ANY-method plot,color-method plot.acf* ## [4] plot.data.frame* plot.decomposed.ts* plot.default ## [7] plot.dendrogram* plot.density* plot.ecdf ## [10] plot.factor* plot.formula* plot.function ## [13] plot.ggplot* plot.gtable* plot.hcl_palettes* ## [16] plot.hclust* plot.histogram* plot.HoltWinters* ## [19] plot.isoreg* plot.lm* plot.medpolish* ## [22] plot.mlm* plot.ppr* plot.prcomp* ## [25] plot.princomp* plot.profile.nls* plot.R6* ## [28] plot.raster* plot.spec* plot.stepfun ## [31] plot.stl* plot.table* plot.trans* ## [34] plot.ts plot.tskernel* plot.TukeyHSD* ## see &#39;?methods&#39; for accessing help and source code Podemos acceder a la ayuda del correspondiente método de la forma habitual (e.g. ?plot.lm), pero puede que algunos métodos no sean objetos definidos como exportables en el namespace del paquete que los implementa (los marcados con un *) y por tanto no son en principio accesibles para el usuario. Siempre podemos acceder a ellos empleando paquete:::metodo o getAnywhere(metodo) (e.g. stats:::plot.lm o getAnywhere(plot.lm)). Para listar los métodos disponibles para una clase, podemos emplear el parámetro class. Por ejemplo: methods(class = &quot;lm&quot;) ## [1] add1 alias anova case.names coerce ## [6] confint cooks.distance deviance dfbeta dfbetas ## [11] drop1 dummy.coef effects extractAIC family ## [16] formula fortify hatvalues influence initialize ## [21] kappa labels logLik model.frame model.matrix ## [26] nobs plot predict print proj ## [31] qr residuals rstandard rstudent show ## [36] simulate slotsFromS3 summary variable.names vcov ## see &#39;?methods&#39; for accessing help and source code Para una programación orientada a objetos más formal la recomendación es emplear el sistema R6. "],["desarrollo.html", "2.4 Desarrollo de funciones y paquetes", " 2.4 Desarrollo de funciones y paquetes Antes de ponerse a programar, sobre todo si puede terminar siendo un código complejo, la recomendación es hacer una búsqueda por si resulta que ya está implementado (o hay algo que podemos tomar como base; es lo bueno de GNU!): en la descripción de los paquetes en CRAN, en los buscadores especializados (rdrr.io, RDocumentation o RSeek), en foros de programación (StackOverflow, StackOverflow.es, Cross Validated), en listas de correo (r-project.org, r-help-es) o directamente en Google (añadiendo “r-project” o similar en la búsqueda). El primer paso es escribir el código como si fuese un programa, asignando valores de prueba a los parámetros, y cuando nos aseguramos de que funciona, reescribirlo como función (yo suelo mantener unos valores de prueba como comentarios por si quiero ejecutar paso a paso el cuerpo de la función). Al finalizar, la recomendación es documentar la función, preferiblemente empleando el formato roxygen2. Por ejemplo: # read_excel_list(path, pattern, ...) # ············································· #&#39; Lee los ficheros xls y xlsx de un directorio #&#39; #&#39; @param path Ruta al directorio con los ficheros excel #&#39; (por defecto el directorio de trabajo). #&#39; @param pattern Expresión regular empleada en la selección de ficheros #&#39; (ver `list.files()`). #&#39; @param ... Parámetros adicionales de `readxl::read_excel()`. #&#39; @return Una lista cuyas componentes son las correspondientes tablas de datos #&#39; (`tibble`) y con nombres los nombres de los archivos sin extensión. #&#39; @examples \\dontrun{ #&#39; data_list &lt;- read_excel_list(&quot;datos&quot;) # &quot;./datos&quot; #&#39; data_all &lt;- dplyr::bind_rows(data_list) #&#39; } # ············································· # Pruebas: # readxl::readxl_example(&quot;geometry.xls&quot;) # path = &quot;C:/Program Files/R/R-4.2.2/library/readxl/extdata&quot; # pattern = &quot;\\\\.(xls|xlsx)$&quot; # Pendiente: # - Controlar posible error al leer # ············································· read_excel_list &lt;- function(path = &quot;.&quot;, pattern = &quot;\\\\.(xls|xlsx)$&quot;, ...) { if (!requireNamespace(readxl)) stop(&quot;&#39;readxl&#39; package required&quot;) files &lt;- dir(path, pattern = pattern, full.names = TRUE) # ?list.files data_list &lt;- vector(length(files), mode = &#39;list&#39;) for (i in seq_along(files)) data_list[[i]] &lt;- readxl::read_excel(files[i], ...) data_names &lt;- sub(&#39;\\\\.xlsx$&#39;, &#39;&#39;, basename(files)) names(data_list) &lt;- data_names data_list } Como ya se comentó, en ocasiones se emplea como punto de partida una función ya implementada en algún paquete de R. En RStudio la forma más sencilla de obtener el código de la función es emplear View(funcion) (si la función es visible, en caso contrario View(paquete:::funcion)). Si la función llama a funciones internas (que no se exportan en el namespace) del paquete que la implementa, podríamos emplear también los tres dobles puntos para llamarlas, pero la recomendación sería descargar el código del paquete (si está en CRAN, un fichero comprimido de la forma paquete_x.y.z.tar.gz que se puede descargar en la sección Downloads de la web del paquete https://CRAN.R-project.org/package=paquete). La mejor forma de organizar funciones es crear un paquete. Para ello se recomienda seguir: Wickham, Hadley (2015). R packages: organize, test, document, and share your code (actualmente 2ª edición en desarrollo con H. Bryan), O’Reilly, 1ª edición. También puede ser de utilidad el manual Writing R Extensions para información adicional. "],["tidyverse.html", "Capítulo 3 El ecosistema tidyverse", " Capítulo 3 El ecosistema tidyverse En los capítulos de esta parte se pretende realizar una breve introducción al ecosistema Tidyverse, una colección de paquetes diseñados de forma uniforme (con la misma filosofía y estilo) para trabajar conjuntamente. La referencia recomendada para usuarios de R que deseen iniciarse en el uso de estos paquetes es: Wickham, H., y Grolemund, G. (2016). R for data science: import, tidy, transform, visualize, and model data, online-castellano, O’Reilly. El paquete tidyverse está diseñado para facilitar la instalación y carga de los paquetes principales de la colección tidyverse con un solo comando. Al instalar este paquete se instalan paquetes que forman el denominado núcleo de tidyverse (se cargan con library(tidyverse)): ggplot2: visualización de datos. dplyr: manipulación de datos. tidyr: reorganización (limpieza) de datos. readr: importación de datos. tibble: tablas de datos (extensión de data.frame). purrr: programación funcional. stringr: manipulación de cadenas de texto. forcats: manipulación de factores. lubridate: manipulación de fechas y horas. y un conjunto de paquetes recomendados (feather, haven, modelr, broom…), entre los que destacaría: readxl: archivos excel. hms: manipulación de medidas de tiempo. httr: web APIs. jsonlite: archivos JSON. rvest: web scraping. xml2: archivos XML. library(tidyverse) También hay paquetes “asociados”: rlang tidyselect tidymodels Muchos otros paquetes están adaptando este estilo (ver e.g. tidyverts): fable, sf… Resumiendo, está muy de moda y puede terminar convirtiéndose en un dialecto del lenguaje R… para mi ya lo es… todo lo que resulte de utilidad es bien venido… Recomiendo evitar estos paquetes en las primeras etapas de formación en R… El estilo de programación tiene como origen la gramática de ggplot2 para crear gráficos de forma declarativa, basado a su vez en: Wilkinson, L. (2005). The Grammar of Graphics. Springer. Yo empleo este paquete como sustituto de los gráficos lattice, en algunos informes finales o aplicaciones para empresas, o para gráficos muy especializados. En condiciones normales prefiero emplear los gráficos estándar de R (mucho más rápidos de generar y programar). Para iniciarse en este paquete lo recomendado es consultar los capítulos Data Visualización y Graphics for communication de R for Data Science. También puede resultar de interés la chuleta). La referencia que cubre con mayor profundidad este paquete es: Wickham, H. (2016). ggplot2: Elegant graphics for Data Analysis (3ª edición, en desarrollo junto a Navarro, D. y Pedersen, T.L.). Springer. En ggplot2 se emplea el operador + para añadir componentes de los gráficos (ver , en Tidyverse se emplea un operador de redirección para añadir operaciones. "],["pipe.html", "3.1 Operador pipe (redirección)", " 3.1 Operador pipe (redirección) El operador %&gt;% (paquete magrittr) permite canalizar la salida de una función a la entrada de otra. Por ejemplo, segundo(primero(datos)) se traduce en datos %&gt;% primero %&gt;% segundo, lo que facilita la lectura de operaciones al escribir las funciones de izquierda a derecha. Desde la versión 4.1 de R está disponible un operador interno |&gt; (aunque yo sigo prefiriendo %&gt;%). Por ejemplo: # El fichero &#39;empleados.RData&#39; contiene datos de empleados de un banco. # Supongamos por ejemplo que estamos interesados en estudiar si hay # discriminación por cuestión de sexo o raza. load(&quot;datos/empleados.RData&quot;) # NOTA: Cuidado con la codificación utf-8 (no declarada) en R &lt; 4.2 # En versiones anteriores de R &lt; 4.2: # load(&quot;datos/empleados.latin1.RData&quot;) # Listamos las etiquetas knitr::kable(attr(empleados, &quot;variable.labels&quot;), col.names = &quot;Etiqueta&quot;) Etiqueta id Código de empleado sexo Sexo fechnac Fecha de nacimiento educ Nivel educativo (años) catlab Categoría laboral salario Salario actual salini Salario inicial tiempemp Meses desde el contrato expprev Experiencia previa (meses) minoria Clasificación étnica sexoraza Clasificación por sexo y raza # Eliminamos las etiquetas para que no molesten... # attr(empleados, &quot;variable.labels&quot;) &lt;- NULL empleados |&gt; subset(catlab == &quot;Directivo&quot;, catlab:sexoraza) |&gt; summary() ## catlab salario salini tiempemp ## Administrativo: 0 Min. : 34410 Min. :15750 Min. :64.00 ## Seguridad : 0 1st Qu.: 51956 1st Qu.:23063 1st Qu.:73.00 ## Directivo :84 Median : 60500 Median :28740 Median :81.00 ## Mean : 63978 Mean :30258 Mean :81.15 ## 3rd Qu.: 71281 3rd Qu.:34058 3rd Qu.:91.00 ## Max. :135000 Max. :79980 Max. :98.00 ## expprev minoria sexoraza ## Min. : 3.00 No:80 Blanca varón :70 ## 1st Qu.: 19.75 Sí: 4 Blanca mujer : 4 ## Median : 52.00 Minoría varón:10 ## Mean : 77.62 Minoría mujer: 0 ## 3rd Qu.:125.25 ## Max. :285.00 Para que una función sea compatible con este tipo de operadores el primer parámetro debería ser siempre los datos. Sin embargo, el operador %&gt;% permite redirigir el resultado de la operación anterior a un parámetro distinto mediante un .. Por ejemplo: # ?&quot;|&gt;&quot; # empleados |&gt; subset(catlab != &quot;Seguridad&quot;) |&gt; droplevels |&gt; # boxplot(salario ~ sexo*catlab, data = .) # ERROR library(magrittr) empleados %&gt;% subset(catlab != &quot;Seguridad&quot;) %&gt;% droplevels() %&gt;% boxplot(salario ~ sexo*catlab, data = .) "],["dplyr.html", "Capítulo 4 Manipulación de datos con dplyr y tidyr", " Capítulo 4 Manipulación de datos con dplyr y tidyr En este capítulo se realiza una breve introducción al paquete dplyr y se comentan algunas de las utilidades del paquete tidyr que pueden resultar de interés5. La referencia recomendada para iniciarse en esta herramienta es el Capítulo 5 Data transformation de R for Data Science. También puede resultar de utilidad la viñeta del paquete Introduction to dplyr o la chuleta. Otra alternativa (más rápida) es data.table pero en versiones recientes ya se puede emplear desde dplyr, como se comenta más adelante.↩︎ "],["dplyr-pkg.html", "4.1 El paquete dplyr", " 4.1 El paquete dplyr library(dplyr) La principal ventaja de dplyr es que permite trabajar (de la misma forma) con datos en distintos formatos: data.frame, tibble. data.table: extensión (paquete backend) dtplyr. conjuntos de datos más grandes que la memoria disponible: extensiones duckdb y arrow (incluyendo almacenamiento en la nube, e.g. AWS). bases de datos relacionales (lenguaje SQL, locales o remotas); extensión dbplyr. grandes volúmenes de datos (incluso almacenados en múltiples servidores; ecosistema Hadoop/Spark): extensión sparklyr. El paquete dplyr permite sustituir operaciones con funciones base de R (como subset, split, apply, sapply, lapply, tapply, aggregate…) por una “gramática” más sencilla para la manipulación de datos. En lugar de operar sobre vectores como la mayoría de las funciones base, opera sobre conjuntos de datos (de forma que es compatible con el operador %&gt;%). Los principales “verbos” (funciones) son: select(): seleccionar variables (ver también rename, relocate, pull). mutate(): crear variables (ver también transmute()). filter(): seleccionar casos/filas (ver también slice()). arrange(): ordenar casos/filas. summarise(): resumir valores. group_by(): permite operaciones por grupo empleando el concepto “dividir-aplicar-combinar” (ungroup() elimina el agrupamiento). NOTA: Para entender el funcionamiento de ciertas funciones (como rowwise()) y las posibilidades en el manejo de datos, hay que tener en cuenta que un data.frame no es más que una lista cuyas componentes (variables) tienen la misma longitud. Realmente las componentes también pueden ser listas de la misma longitud y, por tanto, podemos almacenar casi cualquier estructura de datos en un data.frame. En la primera parte de este capítulo consideraremos solo data.frame por comodidad. Emplearemos como ejemplo los datos de empleados de banca almacenados en el fichero empleados.RData (y supondremos que estamos interesados en estudiar si hay discriminación por cuestión de sexo o raza). load(&quot;datos/empleados.RData&quot;) # En R &lt; 4.2: load(&quot;datos/empleados.latin1.RData&quot;) # Eliminamos las etiquetas para que no molesten... attr(empleados, &quot;variable.labels&quot;) &lt;- NULL En la Sección 4.6 final emplearemos una base de datos relacional como ejemplo. "],["dplyr-variables.html", "4.2 Operaciones con variables (columnas)", " 4.2 Operaciones con variables (columnas) Podemos seleccionar variables con select(): emplea2 &lt;- empleados %&gt;% select(id, sexo, minoria, tiempemp, salini, salario) head(emplea2) ## id sexo minoria tiempemp salini salario ## 1 1 Hombre No 98 27000 57000 ## 2 2 Hombre No 98 18750 40200 ## 3 3 Mujer No 98 12000 21450 ## 4 4 Mujer No 98 13200 21900 ## 5 5 Hombre No 98 21000 45000 ## 6 6 Hombre No 98 13500 32100 Se puede cambiar el nombre (ver también rename()): empleados %&gt;% select(sexo, noblanca = minoria, salario) %&gt;% head() ## sexo noblanca salario ## 1 Hombre No 57000 ## 2 Hombre No 40200 ## 3 Mujer No 21450 ## 4 Mujer No 21900 ## 5 Hombre No 45000 ## 6 Hombre No 32100 Se pueden emplear los nombres de variables como índices: empleados %&gt;% select(sexo:salario) %&gt;% head() ## sexo fechnac educ catlab salario ## 1 Hombre 1952-02-03 15 Directivo 57000 ## 2 Hombre 1958-05-23 16 Administrativo 40200 ## 3 Mujer 1929-07-26 12 Administrativo 21450 ## 4 Mujer 1947-04-15 8 Administrativo 21900 ## 5 Hombre 1955-02-09 15 Administrativo 45000 ## 6 Hombre 1958-08-22 15 Administrativo 32100 # empleados %&gt;% select(-(sexo:salario)) %&gt;% head() empleados %&gt;% select(!(sexo:salario)) %&gt;% head() ## id salini tiempemp expprev minoria sexoraza ## 1 1 27000 98 144 No Blanca varón ## 2 2 18750 98 36 No Blanca varón ## 3 3 12000 98 381 No Minoría varón ## 4 4 13200 98 190 No Minoría varón ## 5 5 21000 98 138 No Blanca varón ## 6 6 13500 98 67 No Blanca varón Se pueden emplear distintas herramientas (selection helpers) para seleccionar variables (ver paquete tidyselect): starts_with, ends_with, contains, matches, num_range: variables que coincidan con un patrón. all_of, any_of: variables de un vectores de caracteres. everything, last_col: todas las variables o la última variable. where(): a partir de una función (e.g. where(is.numeric)) Por ejemplo: empleados %&gt;% select(starts_with(&quot;s&quot;)) %&gt;% head() ## sexo salario salini sexoraza ## 1 Hombre 57000 27000 Blanca varón ## 2 Hombre 40200 18750 Blanca varón ## 3 Mujer 21450 12000 Minoría varón ## 4 Mujer 21900 13200 Minoría varón ## 5 Hombre 45000 21000 Blanca varón ## 6 Hombre 32100 13500 Blanca varón Podemos crear variables con mutate(): emplea2 %&gt;% mutate(incsal = salario - salini, tsal = incsal/tiempemp) %&gt;% head() ## id sexo minoria tiempemp salini salario incsal tsal ## 1 1 Hombre No 98 27000 57000 30000 306.12245 ## 2 2 Hombre No 98 18750 40200 21450 218.87755 ## 3 3 Mujer No 98 12000 21450 9450 96.42857 ## 4 4 Mujer No 98 13200 21900 8700 88.77551 ## 5 5 Hombre No 98 21000 45000 24000 244.89796 ## 6 6 Hombre No 98 13500 32100 18600 189.79592 "],["dplyr-casos.html", "4.3 Operaciones con casos (filas)", " 4.3 Operaciones con casos (filas) Podemos seleccionar casos con filter(): emplea2 %&gt;% filter(sexo == &quot;Mujer&quot;, minoria == &quot;Sí&quot;) %&gt;% head() ## id sexo minoria tiempemp salini salario ## 1 14 Mujer Sí 98 16800 35100 ## 2 23 Mujer Sí 97 11100 24000 ## 3 24 Mujer Sí 97 9000 16950 ## 4 25 Mujer Sí 97 9000 21150 ## 5 40 Mujer Sí 96 9000 19200 ## 6 41 Mujer Sí 96 11550 23550 Podemos reordenar casos con arrange(): emplea2 %&gt;% arrange(salario) %&gt;% head() ## id sexo minoria tiempemp salini salario ## 1 378 Mujer No 70 10200 15750 ## 2 338 Mujer No 74 10200 15900 ## 3 90 Mujer No 92 9750 16200 ## 4 224 Mujer No 82 10200 16200 ## 5 411 Mujer No 68 10200 16200 ## 6 448 Mujer Sí 66 10200 16350 emplea2 %&gt;% arrange(desc(salini), salario) %&gt;% head() ## id sexo minoria tiempemp salini salario ## 1 29 Hombre No 96 79980 135000 ## 2 343 Hombre No 73 60000 103500 ## 3 205 Hombre No 83 52500 66750 ## 4 160 Hombre No 86 47490 66000 ## 5 431 Hombre No 66 45000 86250 ## 6 32 Hombre No 96 45000 110625 Podemos resumir valores con summarise(): empleados %&gt;% summarise(sal.med = mean(salario), n = n()) ## sal.med n ## 1 34419.57 474 Para realizar operaciones con múltiples variables podemos emplear across() (admite selección de variables tidyselect): empleados %&gt;% summarise(across(where(is.numeric), mean), n = n()) ## id educ salario salini tiempemp expprev n ## 1 237.5 13.49156 34419.57 17016.09 81.1097 95.86076 474 # empleados %&gt;% summarise(across(where(is.numeric) &amp; !id, mean), n = n()) empleados %&gt;% summarise(if_any(is.numeric, mean), n = n()) ## if_any(is.numeric, mean) n ## 1 TRUE 474 NOTA: Esta función sustituye a las “variantes de ámbito” _at(), _if() y _all() de versiones anteriores de dplyr (como summarise_at(), summarise_if(), summarise_all(), mutate_at(), mutate_if()…) y también el uso de vars(). En el caso de filter() se puede emplear if_any() e if_all(). Podemos agrupar casos con group_by(): empleados %&gt;% group_by(sexo, minoria) %&gt;% summarise(sal.med = mean(salario), n = n()) %&gt;% ungroup() ## # A tibble: 4 × 4 ## sexo minoria sal.med n ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Hombre No 44475. 194 ## 2 Hombre Sí 32246. 64 ## 3 Mujer No 26707. 176 ## 4 Mujer Sí 23062. 40 empleados %&gt;% group_by(sexo, minoria) %&gt;% summarise(sal.med = mean(salario), n = n(), .groups = &quot;drop&quot;) ## # A tibble: 4 × 4 ## sexo minoria sal.med n ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Hombre No 44475. 194 ## 2 Hombre Sí 32246. 64 ## 3 Mujer No 26707. 176 ## 4 Mujer Sí 23062. 40 # dplyr &gt;= 1.1.0 # packageVersion(&quot;dplyr&quot;) # empleados %&gt;% summarise(sal.med = mean(salario), n = n(), # .by = c(sexo, minoria)) Por defecto la agrupación se mantiene para el resto de operaciones, habría que emplear ungroup() (o el argumento .groups = \"drop\") para eliminarla (se puede emplear group_vars() o str() para ver la agrupación). Desde dplyr 1.1.0 (2023-01-29) está disponible un parámetro .by/by en mutate(), summarise(), filter() y slice() como alternativa a agrupar y desagrupar posteriormente. Para más detalles ver Per-operation grouping with .by/by. "],["herramientas-tidyr.html", "4.4 Herramientas tidyr", " 4.4 Herramientas tidyr Algunas funciones del paquete tidyr que pueden resultar de especial interés son: pivot_wider(): permite transformar valores de grupos de casos a nuevas variables. pivot_longer(): realiza la transformación inversa, colapsar varias columnas en una. Ver la viñeta Pivoting para más detalles. separate(): permite separar una columna de texto en varias (ver también extract()). Ver mortalidad.R en ejemplos. "],["dplyr-join.html", "4.5 Operaciones con tablas de datos", " 4.5 Operaciones con tablas de datos Se emplean funciones xxx_join() (ver la documentación del paquete Join two tbls together, o la vignette Two-table verbs): inner_join(): devuelve las filas de x que tienen valores coincidentes en y, y todas las columnas de x e y. Si hay varias coincidencias entre x e y, se devuelven todas las combinaciones. left_join(): devuelve todas las filas de x y todas las columnas de x e y. Las filas de x sin correspondencia en y contendrán NA en las nuevas columnas. Si hay varias coincidencias entre x e y, se devuelven todas las combinaciones (duplicando las filas). right_join() hace lo contrario, devuelve todas las filas de y. full_join() devuelve todas las filas de x e y (duplicando o asignando NA si es necesario). semi_join(): devuelve las filas de x que tienen valores coincidentes en y, manteniendo sólo las columnas de x (al contrario que inner_join() no duplica filas). anti_join() hace lo contrario, devuelve las filas sin correspondencia. El parámetro by determina las variables clave para las correspondencias. Si no se establece se considerarán todas las que tengan el mismo nombre en ambas tablas. Se puede establecer a un vector de nombres coincidentes y en caso de que los nombres sean distintos a un vector con nombres de la forma c(\"clave_x\" = \"clave_y\"). Adicionalmente, si las tablas x e y tienen las mismas variables, se pueden combinar las observaciones con operaciones de conjuntos: intersect(x, y): observaciones en x y en y. union(x, y): observaciones en x o y no duplicadas. setdiff(x, y): observaciones en x pero no en y. "],["dbplyr.html", "4.6 Bases de datos con dplyr", " 4.6 Bases de datos con dplyr Para poder usar tablas en bases de datos relacionales con dplyr hay que emplear el paquete dbplyr (convierte automáticamente el código de dplyr en consultas SQL). Algunos enlaces: Best Practices in Working with Databases Introduction to dbplyr Data Carpentry: SQL databases and R, R and Data – When Should we Use Relational Databases? 4.6.1 Ejemplos Como ejemplo emplearemos la base de datos de SQLite Sample Database Tutorial, almacenada en el archivo chinook.db. # install.packages(&#39;dbplyr&#39;) library(dplyr) library(dbplyr) En primer lugar hay que conectar la base de datos: chinook &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;datos/chinook.db&quot;) Podemos listar las tablas: src_dbi(chinook) ## src: sqlite 3.39.4 [E:\\OneDrive - Universidade da Coruña\\__Actual\\__IGE\\_book_notasr\\datos\\chinook.db] ## tbls: albums, artists, customers, employees, genres, invoice_items, invoices, ## media_types, playlist_track, playlists, sqlite_sequence, sqlite_stat1, tracks Para enlazar una tabla: invoices &lt;- tbl(chinook, &quot;invoices&quot;) invoices ## # Source: table&lt;invoices&gt; [?? x 9] ## # Database: sqlite 3.39.4 [E:\\OneDrive - Universidade da Coruña\\__Actual\\__IGE\\_book_notasr\\datos\\chinook.db] ## InvoiceId CustomerId InvoiceD…¹ Billi…² Billi…³ Billi…⁴ Billi…⁵ Billi…⁶ Total ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2 2009-01-0… Theodo… Stuttg… &lt;NA&gt; Germany 70174 1.98 ## 2 2 4 2009-01-0… Ullevå… Oslo &lt;NA&gt; Norway 0171 3.96 ## 3 3 8 2009-01-0… Grétry… Brusse… &lt;NA&gt; Belgium 1000 5.94 ## 4 4 14 2009-01-0… 8210 1… Edmont… AB Canada T6G 2C7 8.91 ## 5 5 23 2009-01-1… 69 Sal… Boston MA USA 2113 13.9 ## 6 6 37 2009-01-1… Berger… Frankf… &lt;NA&gt; Germany 60316 0.99 ## 7 7 38 2009-02-0… Barbar… Berlin &lt;NA&gt; Germany 10779 1.98 ## 8 8 40 2009-02-0… 8, Rue… Paris &lt;NA&gt; France 75002 1.98 ## 9 9 42 2009-02-0… 9, Pla… Bordea… &lt;NA&gt; France 33000 3.96 ## 10 10 46 2009-02-0… 3 Chat… Dublin Dublin Ireland &lt;NA&gt; 5.94 ## # … with more rows, and abbreviated variable names ¹​InvoiceDate, ## # ²​BillingAddress, ³​BillingCity, ⁴​BillingState, ⁵​BillingCountry, ## # ⁶​BillingPostalCode Ojo [?? x 9]: de momento no conoce el número de filas. nrow(invoices) ## [1] NA Podemos mostrar la consulta SQL correspondiente a una operación: show_query(head(invoices)) ## &lt;SQL&gt; ## SELECT * ## FROM `invoices` ## LIMIT 6 # str(head(invoices)) Al trabajar con bases de datos, dplyr intenta ser lo más vago posible: No exporta datos a R a menos que se pida explícitamente (colect()). Retrasa cualquier operación lo máximo posible: agrupa todo lo que se desea hacer y luego hace una única petición a la base de datos. invoices %&gt;% head %&gt;% collect ## # A tibble: 6 × 9 ## InvoiceId CustomerId InvoiceDate Billi…¹ Billi…² Billi…³ Billi…⁴ Billi…⁵ Total ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2 2009-01-01… Theodo… Stuttg… &lt;NA&gt; Germany 70174 1.98 ## 2 2 4 2009-01-02… Ullevå… Oslo &lt;NA&gt; Norway 0171 3.96 ## 3 3 8 2009-01-03… Grétry… Brusse… &lt;NA&gt; Belgium 1000 5.94 ## 4 4 14 2009-01-06… 8210 1… Edmont… AB Canada T6G 2C7 8.91 ## 5 5 23 2009-01-11… 69 Sal… Boston MA USA 2113 13.9 ## 6 6 37 2009-01-19… Berger… Frankf… &lt;NA&gt; Germany 60316 0.99 ## # … with abbreviated variable names ¹​BillingAddress, ²​BillingCity, ## # ³​BillingState, ⁴​BillingCountry, ⁵​BillingPostalCode invoices %&gt;% count # número de filas ## # Source: SQL [1 x 1] ## # Database: sqlite 3.39.4 [E:\\OneDrive - Universidade da Coruña\\__Actual\\__IGE\\_book_notasr\\datos\\chinook.db] ## n ## &lt;int&gt; ## 1 412 Por ejemplo, para obtener el importe mínimo, máximo y la media de las facturas: res &lt;- invoices %&gt;% summarise(min = min(Total, na.rm = TRUE), max = max(Total, na.rm = TRUE), med = mean(Total, na.rm = TRUE)) # show_query(res) res %&gt;% collect ## # A tibble: 1 × 3 ## min max med ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.99 25.9 5.65 Para obtener el total de las facturas de cada uno de los países: res &lt;- invoices %&gt;% group_by(BillingCountry) %&gt;% summarise(n = n(), total = sum(Total, na.rm = TRUE)) # show_query(res) res %&gt;% collect ## # A tibble: 24 × 3 ## BillingCountry n total ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Argentina 7 37.6 ## 2 Australia 7 37.6 ## 3 Austria 7 42.6 ## 4 Belgium 7 37.6 ## 5 Brazil 35 190. ## 6 Canada 56 304. ## 7 Chile 7 46.6 ## 8 Czech Republic 14 90.2 ## 9 Denmark 7 37.6 ## 10 Finland 7 41.6 ## # … with 14 more rows Para obtener un listado con Nombre y Apellidos de cliente y el importe de cada una de sus facturas (Hint: WHERE customer.CustomerID=invoices.CustomerID): customers &lt;- tbl(chinook, &quot;customers&quot;) tbl_vars(customers) ## &lt;dplyr:::vars&gt; ## [1] &quot;CustomerId&quot; &quot;FirstName&quot; &quot;LastName&quot; &quot;Company&quot; &quot;Address&quot; ## [6] &quot;City&quot; &quot;State&quot; &quot;Country&quot; &quot;PostalCode&quot; &quot;Phone&quot; ## [11] &quot;Fax&quot; &quot;Email&quot; &quot;SupportRepId&quot; res &lt;- customers %&gt;% inner_join(invoices, by = &quot;CustomerId&quot;) %&gt;% select(FirstName, LastName, Country, Total) show_query(res) ## &lt;SQL&gt; ## SELECT `FirstName`, `LastName`, `Country`, `Total` ## FROM ( ## SELECT ## `LHS`.`CustomerId` AS `CustomerId`, ## `FirstName`, ## `LastName`, ## `Company`, ## `Address`, ## `City`, ## `State`, ## `Country`, ## `PostalCode`, ## `Phone`, ## `Fax`, ## `Email`, ## `SupportRepId`, ## `InvoiceId`, ## `InvoiceDate`, ## `BillingAddress`, ## `BillingCity`, ## `BillingState`, ## `BillingCountry`, ## `BillingPostalCode`, ## `Total` ## FROM `customers` AS `LHS` ## INNER JOIN `invoices` AS `RHS` ## ON (`LHS`.`CustomerId` = `RHS`.`CustomerId`) ## ) res %&gt;% collect ## # A tibble: 412 × 4 ## FirstName LastName Country Total ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Luís Gonçalves Brazil 3.98 ## 2 Luís Gonçalves Brazil 3.96 ## 3 Luís Gonçalves Brazil 5.94 ## 4 Luís Gonçalves Brazil 0.99 ## 5 Luís Gonçalves Brazil 1.98 ## 6 Luís Gonçalves Brazil 13.9 ## 7 Luís Gonçalves Brazil 8.91 ## 8 Leonie Köhler Germany 1.98 ## 9 Leonie Köhler Germany 13.9 ## 10 Leonie Köhler Germany 8.91 ## # … with 402 more rows Para listar los 10 mejores clientes (aquellos a los que se les ha facturado más cantidad) indicando Nombre, Apellidos, Pais y el importe total de su facturación: customers %&gt;% inner_join(invoices, by = &quot;CustomerId&quot;) %&gt;% group_by(CustomerId) %&gt;% summarise(FirstName, LastName, country, total = sum(Total, na.rm = TRUE)) %&gt;% arrange(desc(total)) %&gt;% head(10) %&gt;% collect ## # A tibble: 10 × 5 ## CustomerId FirstName LastName Country total ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 6 Helena Holý Czech Republic 49.6 ## 2 26 Richard Cunningham USA 47.6 ## 3 57 Luis Rojas Chile 46.6 ## 4 45 Ladislav Kovács Hungary 45.6 ## 5 46 Hugh O&#39;Reilly Ireland 45.6 ## 6 28 Julia Barnett USA 43.6 ## 7 24 Frank Ralston USA 43.6 ## 8 37 Fynn Zimmermann Germany 43.6 ## 9 7 Astrid Gruber Austria 42.6 ## 10 25 Victor Stevens USA 42.6 Al finalizar hay que desconectar la base de datos: DBI::dbDisconnect(chinook) "],["referencias.html", "Referencias", " Referencias Fernández-Casal R., Costa J. y Oviedo de la Fuente, M. (2021). Aprendizaje Estadístico. github. Fernández-Casal R., Roca-Pardiñas J., Costa J. y Oviedo-de la Fuente M. (2023). Introducción al Análisis de Datos con R. ISBN: 978-84-09-41823-7. github. Grolemund, G. (2014). Hands-on programming with R: Write your own functions and simulations, O’Reilly. Kuhn, M. y Silge, J. (2022). Tidy Modeling with R. O’Reill. Matloff, N. (2011). The art of R programming: A tour of statistical software design, No Starch Press. Wickham, H. (2015). R packages: organize, test, document, and share your code (actualmente 2ª edición en desarrollo con H. Bryan), O’Reilly, 1ª edición. Wickham, H. (2019). Advanced R, 2ª edición, Chapman &amp; Hall, 1ª edición.. Wickham, H., y Grolemund, G. (2016). R for data science: import, tidy, transform, visualize, and model data, online-castellano, O’Reilly. NOTA: En la bibliografía complementaria se incluyen algunas de estas referencias, y una selección de libros en abierto, organizados por temas. "],["bibliografía-por-temas.html", "Bibliografía por temas", " Bibliografía por temas En preparación… A continuación se muestra una selección de libros en abierto que considero que pueden resultar de utilidad. Para referencias adicionales recomiendo consultar: Baruffa, O. (2022). Big Book of R: Your last-ever bookmark (hopefully…). Iniciación a la programación en R Wickham, H., y Grolemund, G. (2016). R for data science: import, tidy, transform, visualize, and model data, online-castellano, O’Reilly. Grolemund, G. (2014). Hands-on programming with R: Write your own functions and simulations, O’Reilly. Fernández-Casal R., Roca-Pardiñas J., Costa J., y Oviedo de la Fuente, M. (2022). Introducción al Análisis de Datos con R. github. Peng, R.D. (2022). R Programming for Data Science, Leanpub. Programación avanzada en R Wickham, H. (2019). Advanced R, 2ª edición, Chapman &amp; Hall, 1ª edición.. Wickham, H. (2015). R packages: organize, test, document, and share your code (actualmente 2ª edición en desarrollo con H. Bryan), O’Reilly, 1ª edición. Rmarkdown Fernández-Casal, R. y Cotos-Yáñez, T.R. (2018). Escritura de libros con bookdown, github. Incluye un apéndice con una Introducción a RMarkdown. Gráficos Chang, W. (2023). The R Graphics Cookbook. O’Reilly. Wickham, H. (2016). ggplot2: Elegant graphics for Data Analysis (3ª edición, en desarrollo junto a Navarro, D. y Pedersen, T.L.). Springer. Regresión y aprendizaje estadístico Fernández-Casal R., Costa J. y Oviedo de la Fuente, M. (2021). Aprendizaje Estadístico. github. Kuhn, M., y Silge, J. (2022). Tidy Modeling with R, O’Reilly. Fernández-Casal R., Cao R. y Costa J. (2023). Técnicas de Simulación y Remuestreo (github). La anterior edición (Fernández-Casal R. y Cao R., 2022, Simulación Estadística) está disponible en la rama primera_edicion. Datos temporales y espaciales Fernández-Casal R. y Cotos-Yáñez T.R. (2021). Estadística Espacial con R. github. Hyndman, R.J., y Athanasopoulos, G. (2021). Forecasting: principles and practice. OTexts. Lovelace, R., Nowosad, J., y Muenchow, J. (2019). Geocomputation with R. CRC. Moraga, P. (2019). Geospatial health data: Modeling and visualization with R-INLA and shiny, CRC. Pebesma, E., y Bivand, R. (2021). Spatial Data Science. Datos faltantes Buuren, S. (2018). Flexible Imputation of Missing Data, Chapman &amp; Hall. Manuales oficiales https://cran.r-project.org/manuals.html Intro to R R Data Import/Export R Installation and Administration Writing R extensions The R language definition R Internals "],["links.html", "Enlaces", " Enlaces Repositorio: rubenfcasal/book_notasr Recursos para el aprendizaje de R: En este post se muestran algunos recursos que pueden ser útiles para el aprendizaje de R y la obtención de ayuda. Bookdown: Notas de programación en R Introducción a RMarkdown. Posit (RStudio) Blog Videos Chuletas (Cheatsheets) tidyverse: dplyr tibble tidyr stringr readr Best Practices in Working with Databases tidymodels sparklyr shiny "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
